function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import useScrollY from './useScrollY';
import { isHeaderClipped, plusCalc, toValidCssValue } from '../utils';
export var useRelativeHeaders = function useRelativeHeaders(headerConfigs, sidebarId) {
  var scrollY = useScrollY();
  var relativeConfigs = headerConfigs.filter(function (config) {
    return isHeaderClipped(config, sidebarId) && !config.hidden && config.position === 'relative';
  });
  var offset = plusCalc.apply(void 0, _toConsumableArray(relativeConfigs.map(function (c) {
    return "-".concat(toValidCssValue(c.initialHeight));
  })));
  return "max(".concat(toValidCssValue(-scrollY), ", ").concat(offset, ")");
};
export default useRelativeHeaders;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ob29rcy91c2VSZWxhdGl2ZUhlYWRlcnMudHMiXSwibmFtZXMiOlsidXNlU2Nyb2xsWSIsImlzSGVhZGVyQ2xpcHBlZCIsInBsdXNDYWxjIiwidG9WYWxpZENzc1ZhbHVlIiwidXNlUmVsYXRpdmVIZWFkZXJzIiwiaGVhZGVyQ29uZmlncyIsInNpZGViYXJJZCIsInNjcm9sbFkiLCJyZWxhdGl2ZUNvbmZpZ3MiLCJmaWx0ZXIiLCJjb25maWciLCJoaWRkZW4iLCJwb3NpdGlvbiIsIm9mZnNldCIsIm1hcCIsImMiLCJpbml0aWFsSGVpZ2h0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxVQUFQLE1BQXVCLGNBQXZCO0FBQ0EsU0FBU0MsZUFBVCxFQUEwQkMsUUFBMUIsRUFBb0NDLGVBQXBDLFFBQTJELFVBQTNEO0FBR0EsT0FBTyxJQUFNQyxrQkFBa0IsR0FBRyxTQUFyQkEsa0JBQXFCLENBQ2hDQyxhQURnQyxFQUVoQ0MsU0FGZ0MsRUFHN0I7QUFDSCxNQUFNQyxPQUFPLEdBQUdQLFVBQVUsRUFBMUI7QUFDQSxNQUFNUSxlQUFlLEdBQUdILGFBQWEsQ0FBQ0ksTUFBZCxDQUN0QixVQUFBQyxNQUFNO0FBQUEsV0FDSlQsZUFBZSxDQUFDUyxNQUFELEVBQVNKLFNBQVQsQ0FBZixJQUNBLENBQUNJLE1BQU0sQ0FBQ0MsTUFEUixJQUVBRCxNQUFNLENBQUNFLFFBQVAsS0FBb0IsVUFIaEI7QUFBQSxHQURnQixDQUF4QjtBQU1BLE1BQU1DLE1BQU0sR0FBR1gsUUFBUSxNQUFSLDRCQUNWTSxlQUFlLENBQUNNLEdBQWhCLENBQW9CLFVBQUFDLENBQUM7QUFBQSxzQkFBUVosZUFBZSxDQUFDWSxDQUFDLENBQUNDLGFBQUgsQ0FBdkI7QUFBQSxHQUFyQixDQURVLEVBQWY7QUFHQSx1QkFBY2IsZUFBZSxDQUFDLENBQUNJLE9BQUYsQ0FBN0IsZUFBNENNLE1BQTVDO0FBQ0QsQ0FmTTtBQWlCUCxlQUFlVCxrQkFBZiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB1c2VTY3JvbGxZIGZyb20gJy4vdXNlU2Nyb2xsWSc7XG5pbXBvcnQgeyBpc0hlYWRlckNsaXBwZWQsIHBsdXNDYWxjLCB0b1ZhbGlkQ3NzVmFsdWUgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBIZWFkZXJDb25maWcgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCB1c2VSZWxhdGl2ZUhlYWRlcnMgPSAoXG4gIGhlYWRlckNvbmZpZ3M6IEhlYWRlckNvbmZpZ1tdLFxuICBzaWRlYmFySWQ6IHN0cmluZ1xuKSA9PiB7XG4gIGNvbnN0IHNjcm9sbFkgPSB1c2VTY3JvbGxZKCk7XG4gIGNvbnN0IHJlbGF0aXZlQ29uZmlncyA9IGhlYWRlckNvbmZpZ3MuZmlsdGVyKFxuICAgIGNvbmZpZyA9PlxuICAgICAgaXNIZWFkZXJDbGlwcGVkKGNvbmZpZywgc2lkZWJhcklkKSAmJlxuICAgICAgIWNvbmZpZy5oaWRkZW4gJiZcbiAgICAgIGNvbmZpZy5wb3NpdGlvbiA9PT0gJ3JlbGF0aXZlJ1xuICApO1xuICBjb25zdCBvZmZzZXQgPSBwbHVzQ2FsYyhcbiAgICAuLi5yZWxhdGl2ZUNvbmZpZ3MubWFwKGMgPT4gYC0ke3RvVmFsaWRDc3NWYWx1ZShjLmluaXRpYWxIZWlnaHQpfWApXG4gICk7XG4gIHJldHVybiBgbWF4KCR7dG9WYWxpZENzc1ZhbHVlKC1zY3JvbGxZKX0sICR7b2Zmc2V0fSlgO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdXNlUmVsYXRpdmVIZWFkZXJzO1xuIl19