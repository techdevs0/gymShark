function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { keys } from "@material-ui/core/styles/createBreakpoints";
import createDisplayNone from "./createDisplayNone";
export var sortBreakpoints = function sortBreakpoints(breakpoints) {
  return breakpoints.sort(function (a, b) {
    return keys.indexOf(a) - keys.indexOf(b);
  });
};
export var combineSiblings = function combineSiblings(siblings) {
  return siblings.reduce(function (result, curr) {
    return [].concat(_toConsumableArray(result), _toConsumableArray(Object.keys(curr)));
  }, []);
};
export var isLowerBreakpointFromSibling = function isLowerBreakpointFromSibling(selfBreakpoints, siblingsBreakpoints, bp) {
  var keysUtilBreakpoint = keys.slice(0, keys.indexOf(bp));
  var isSibling = false;
  var isSelf = false;
  keysUtilBreakpoint.reverse().forEach(function (v) {
    if (!isSibling && !isSelf) {
      if (siblingsBreakpoints.includes(v)) {
        isSibling = true;
      }

      if (selfBreakpoints.includes(v)) {
        isSelf = true;
      }
    }
  });
  return isSibling;
};
export var getHiddenRange = function getHiddenRange(self, siblings) {
  var selfBreakpoints = sortBreakpoints(Object.keys(self));
  var siblingsBreakpoints = sortBreakpoints(combineSiblings(siblings));
  var found = false;
  var result = [];
  keys.forEach(function (bp) {
    if (selfBreakpoints.includes(bp) || siblingsBreakpoints.includes(bp)) {
      found = true; // logic continue

      if (selfBreakpoints.includes(bp) && siblingsBreakpoints.includes(bp)) {
        console.warn("[Warning]! seems like there are multiple configs for breakpoint: ".concat(bp, ", this can cause unexpected behavior. Please make sure that you only have one variant config for each breakpoint."));
      }

      if (siblingsBreakpoints.includes(bp)) {
        result.push(bp);
      }
    } else {
      if (!found) {
        result.push(bp);
      } else if (isLowerBreakpointFromSibling(selfBreakpoints, siblingsBreakpoints, bp)) {
        result.push(bp);
      }
    }
  });
  return result;
};

var createHiddenStyles = function createHiddenStyles(self) {
  var siblings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var breakpoints = arguments.length > 2 ? arguments[2] : undefined;
  if (!self || !breakpoints) return {};
  var hiddenRange = getHiddenRange(self, siblings);
  return createDisplayNone(hiddenRange, breakpoints);
};

export default createHiddenStyles;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9jcmVhdGVIaWRkZW5TdHlsZXMudHMiXSwibmFtZXMiOlsia2V5cyIsImNyZWF0ZURpc3BsYXlOb25lIiwic29ydEJyZWFrcG9pbnRzIiwiYnJlYWtwb2ludHMiLCJzb3J0IiwiYSIsImIiLCJpbmRleE9mIiwiY29tYmluZVNpYmxpbmdzIiwic2libGluZ3MiLCJyZWR1Y2UiLCJyZXN1bHQiLCJjdXJyIiwiT2JqZWN0IiwiaXNMb3dlckJyZWFrcG9pbnRGcm9tU2libGluZyIsInNlbGZCcmVha3BvaW50cyIsInNpYmxpbmdzQnJlYWtwb2ludHMiLCJicCIsImtleXNVdGlsQnJlYWtwb2ludCIsInNsaWNlIiwiaXNTaWJsaW5nIiwiaXNTZWxmIiwicmV2ZXJzZSIsImZvckVhY2giLCJ2IiwiaW5jbHVkZXMiLCJnZXRIaWRkZW5SYW5nZSIsInNlbGYiLCJmb3VuZCIsImNvbnNvbGUiLCJ3YXJuIiwicHVzaCIsImNyZWF0ZUhpZGRlblN0eWxlcyIsImhpZGRlblJhbmdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxTQUdFQSxJQUhGLFFBSU8sNENBSlA7QUFNQSxPQUFPQyxpQkFBUCxNQUE4QixxQkFBOUI7QUFXQSxPQUFPLElBQU1DLGVBQWUsR0FBRyxTQUFsQkEsZUFBa0IsQ0FBQ0MsV0FBRDtBQUFBLFNBQzdCQSxXQUFXLENBQUNDLElBQVosQ0FBaUIsVUFBQ0MsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsV0FBVU4sSUFBSSxDQUFDTyxPQUFMLENBQWFGLENBQWIsSUFBa0JMLElBQUksQ0FBQ08sT0FBTCxDQUFhRCxDQUFiLENBQTVCO0FBQUEsR0FBakIsQ0FENkI7QUFBQSxDQUF4QjtBQUdQLE9BQU8sSUFBTUUsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFDQyxRQUFEO0FBQUEsU0FDN0JBLFFBQVEsQ0FBQ0MsTUFBVCxDQUFnQixVQUFDQyxNQUFELEVBQVNDLElBQVQ7QUFBQSx3Q0FBc0JELE1BQXRCLHNCQUFp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QU9SLGlCQUFpQixDQUFDZ0MsV0FBRCxFQUFjOUIsV0FBZCxDQUF4QjtBQUNELENBVEQ7O0FBV0EsZUFBZTZCLGtCQUFmIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQnJlYWtwb2ludCxcbiAgQnJlYWtwb2ludHMsXG4gIGtleXMsXG59IGZyb20gXCJAbWF0ZXJpYWwtdWkvY29yZS9zdHlsZXMvY3JlYXRlQnJlYWtwb2ludHNcIlxuaW1wb3J0IHsgTWVkaWFRdWVyaWVzIH0gZnJvbSBcIi4vY3JlYXRlQnJlYWtwb2ludFN0eWxlc1wiXG5pbXBvcnQgY3JlYXRlRGlzcGxheU5vbmUgZnJvbSBcIi4vY3JlYXRlRGlzcGxheU5vbmVcIlxuaW1wb3J0IHsgUmVzdWx0U3R5bGUgfSBmcm9tIFwiLi4vdHlwZXNcIlxuXG5pbnRlcmZhY2UgQ3JlYXRlSGlkZGVuU3R5bGVzIHtcbiAgKFxuICAgIHNlbGY6IFJlc3VsdFN0eWxlLFxuICAgIHNpYmxpbmdzOiBSZXN1bHRTdHlsZVtdLFxuICAgIGJyZWFrcG9pbnRzOiBCcmVha3BvaW50cyxcbiAgKTogTWVkaWFRdWVyaWVzXG59XG5cbmV4cG9ydCBjb25zdCBzb3J0QnJlYWtwb2ludHMgPSAoYnJlYWtwb2ludHM6IEJyZWFrcG9pbnRbXSkgPT5cbiAgYnJlYWtwb2ludHMuc29ydCgoYSwgYikgPT4ga2V5cy5pbmRleE9mKGEpIC0ga2V5cy5pbmRleE9mKGIpKVxuXG5leHBvcnQgY29uc3QgY29tYmluZVNpYmxpbmdzID0gKHNpYmxpbmdzOiBSZXN1bHRTdHlsZVtdKSA9PlxuICBzaWJsaW5ncy5yZWR1Y2UoKHJlc3VsdCwgY3VycikgPT4gWy4uLnJlc3VsdCwgLi4uT2JqZWN0LmtleXMoY3VycildLCBbXSlcblxuZXhwb3J0IGNvbnN0IGlzTG93ZXJCcmVha3BvaW50RnJvbVNpYmxpbmcgPSAoXG4gIHNlbGZCcmVha3BvaW50czogQnJlYWtwb2ludFtdLFxuICBzaWJsaW5nc0JyZWFrcG9pbnRzOiBCcmVha3BvaW50W10sXG4gIGJwOiBCcmVha3BvaW50XG4pID0+IHtcbiAgY29uc3Qga2V5c1V0aWxCcmVha3BvaW50ID0ga2V5cy5zbGljZSgwLCBrZXlzLmluZGV4T2YoYnApKVxuICBsZXQgaXNTaWJsaW5nID0gZmFsc2VcbiAgbGV0IGlzU2VsZiA9IGZhbHNlXG4gIGtleXNVdGlsQnJlYWtwb2ludC5yZXZlcnNlKCkuZm9yRWFjaCh2ID0+IHtcbiAgICBpZiAoIWlzU2libGluZyAmJiAhaXNTZWxmKSB7XG4gICAgICBpZiAoc2libGluZ3NCcmVha3BvaW50cy5pbmNsdWRlcyh2KSkge1xuICAgICAgICBpc1NpYmxpbmcgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoc2VsZkJyZWFrcG9pbnRzLmluY2x1ZGVzKHYpKSB7XG4gICAgICAgIGlzU2VsZiA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBpc1NpYmxpbmdcbn1cblxuZXhwb3J0IGNvbnN0IGdldEhpZGRlblJhbmdlID0gKHNlbGY6IFJlc3VsdFN0eWxlLCBzaWJsaW5nczogUmVzdWx0U3R5bGVbXSkgPT4ge1xuICBjb25zdCBzZWxmQnJlYWtwb2ludHMgPSBzb3J0QnJlYWtwb2ludHMoT2JqZWN0LmtleXMoc2VsZikgYXMgQnJlYWtwb2ludFtdKVxuICBjb25zdCBzaWJsaW5nc0JyZWFrcG9pbnRzID0gc29ydEJyZWFrcG9pbnRzKGNvbWJpbmVTaWJsaW5ncyhzaWJsaW5ncykpXG4gIGxldCBmb3VuZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IEJyZWFrcG9pbnRbXSA9IFtdXG4gIGtleXMuZm9yRWFjaChicCA9PiB7XG4gICAgaWYgKHNlbGZCcmVha3BvaW50cy5pbmNsdWRlcyhicCkgfHwgc2libGluZ3NCcmVha3BvaW50cy5pbmNsdWRlcyhicCkpIHtcbiAgICAgIGZvdW5kID0gdHJ1ZVxuICAgICAgLy8gbG9naWMgY29udGludWVcbiAgICAgIGlmIChzZWxmQnJlYWtwb2ludHMuaW5jbHVkZXMoYnApICYmIHNpYmxpbmdzQnJlYWtwb2ludHMuaW5jbHVkZXMoYnApKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgW1dhcm5pbmddISBzZWVtcyBsaWtlIHRoZXJlIGFyZSBtdWx0aXBsZSBjb25maWdzIGZvciBicmVha3BvaW50OiAke2JwfSwgdGhpcyBjYW4gY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvci4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHlvdSBvbmx5IGhhdmUgb25lIHZhcmlhbnQgY29uZmlnIGZvciBlYWNoIGJyZWFrcG9pbnQuYFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoc2libGluZ3NCcmVha3BvaW50cy5pbmNsdWRlcyhicCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYnApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYnApXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBpc0xvd2VyQnJlYWtwb2ludEZyb21TaWJsaW5nKHNlbGZCcmVha3BvaW50cywgc2libGluZ3NCcmVha3BvaW50cywgYnApXG4gICAgICApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYnApXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IGNyZWF0ZUhpZGRlblN0eWxlczogQ3JlYXRlSGlkZGVuU3R5bGVzID0gKFxuICBzZWxmLFxuICBzaWJsaW5ncyA9IFtdLFxuICBicmVha3BvaW50c1xuKSA9PiB7XG4gIGlmICghc2VsZiB8fCAhYnJlYWtwb2ludHMpIHJldHVybiB7fVxuICBjb25zdCBoaWRkZW5SYW5nZSA9IGdldEhpZGRlblJhbmdlKHNlbGYsIHNpYmxpbmdzKVxuXG4gIHJldHVybiBjcmVhdGVEaXNwbGF5Tm9uZShoaWRkZW5SYW5nZSwgYnJlYWtwb2ludHMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUhpZGRlblN0eWxlc1xuIl19