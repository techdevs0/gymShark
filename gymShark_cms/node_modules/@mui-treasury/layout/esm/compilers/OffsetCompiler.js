function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { combineBreakpoints, pickNearestBreakpoint } from '../utils';
export default (function (sidebar, header, subheader) {
  return {
    getResultStyle: function getResultStyle(sidebarId, predicate, getHeight) {
      var result = {};
      var found = false;
      var configMap = sidebar.configMapById[sidebarId];

      if (configMap) {
        var breakpoints = combineBreakpoints(configMap, header, subheader.configMap);
        breakpoints.forEach(function (bp) {
          var sidebarConfig = pickNearestBreakpoint(configMap, bp);
          var headerConfig = pickNearestBreakpoint(header, bp);
          var subheaderConfigs = Object.keys(subheader.configMapById).map(function (subheaderId) {
            return pickNearestBreakpoint(subheader.configMapById[subheaderId], bp);
          }).filter(function (c) {
            return !!c && !c.hidden;
          });

          if (sidebarConfig) {
            if (predicate(sidebarConfig, headerConfig, subheaderConfigs)) {
              found = true;
              result[bp] = {
                height: getHeight([headerConfig].concat(_toConsumableArray(subheaderConfigs)))
              };
            } else if (found) {
              found = false;
              result[bp] = {
                height: 0
              };
            }
          }
        });
      }

      return result;
    }
  };
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21waWxlcnMvT2Zmc2V0Q29tcGlsZXIudHMiXSwibmFtZXMiOlsiY29tYmluZUJyZWFrcG9pbnRzIiwicGlja05lYXJlc3RCcmVha3BvaW50Iiwic2lkZWJhciIsImhlYWRlciIsInN1YmhlYWRlciIsImdldFJlc3VsdFN0eWxlIiwic2lkZWJhcklkIiwicHJlZGljYXRlIiwiZ2V0SGVpZ2h0IiwicmVzdWx0IiwiZm91bmQiLCJjb25maWdNYXAiLCJjb25maWdNYXBCeUlkIiwiYnJlYWtwb2ludHMiLCJmb3JFYWNoIiwiYnAiLCJzaWRlYmFyQ29uZmlnIiwiaGVhZGVyQ29uZmlnIiwic3ViaGVhZGVyQ29uZmlncyIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJzdWJoZWFkZXJJZCIsImZpbHRlciIsImMiLCJoaWRkZW4iLCJoZWlnaHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQVFBLFNBQVNBLGtCQUFULEVBQTZCQyxxQkFBN0IsUUFBMEQsVUFBMUQ7QUFFQSxnQkFBZSxVQUNiQyxPQURhLEVBSWJDLE1BSmEsRUFLYkMsU0FMYSxFQU1WO0FBQ0gsU0FBTztBQUNMQyxJQUFBQSxjQUFjLEVBQUUsd0JBQ2RDLFNBRGMsRUFFZEMsU0FGYyxFQU9kQyxTQVBjLEVBUVg7QUFDSCxVQUFNQyxNQUFtQixHQUFHLEVBQTVCO0FBQ0EsVUFBSUMsS0FBYyxHQUFHLEtBQXJCO0FBQ0EsVUFBTUMsU0FBUyxHQUFHVCxPQUFPLENBQUNVLGFBQVIsQ0FBc0JOLFNBQXRCLENBQWxCOztBQUNBLFVBQUlLLFNBQUosRUFBZTtBQUNiLFlBQU1FLFdBQVcsR0FBR2Isa0JBQWtCLENBQ3BDVyxTQURvQyxFQUVwQ1IsTUFGb0MsRUFHcENDLFNBQVMsQ0FBQ08sU0FIMEIsQ0FBdEM7QUFLQUUsUUFBQUEsV0FBVyxDQUFDQyxPQUFaLENBQW9CLFVBQUFDLEVBQUUsRUFBSTtBQUN4QixjQUFNQyxhQUFhLEdBQUdmLHFCQUFxQixDQUFJVSxTQUFKLEVBQXNCSSxFQUF0QixDQUEzQztBQUNBLGNBQU1FLFlBQVksR0FBR2hCLHFCQUFxQixDQUFDRSxNQUFELEVBQVNZLEVBQVQsQ0FBMUM7QUFDQSxjQUFNRyxnQkFBZ0IsR0FBR0MsTUFBTSxDQUFDQyxJQUFQLENBQVloQixTQUFTLENBQUNRLGFBQXRCLEVBQ3RCUyxHQURzQixDQUNsQixVQUFBQyxXQUFXLEVBQUk7QUFDbEIsbUJBQU9yQixxQkFBcUIsQ0FDMUJHLFNBQVMsQ0FBQ1EsYUFBVixDQUF3QlUsV0FBeEIsQ0FEMEIsRUFFMUJQLEVBRjBCLENBQTVCO0FBSUQsV0FOc0IsRUFPdEJRLE1BUHNCLENBT2YsVUFBQUMsQ0FBQztBQUFBLG1CQUFJLENBQUMsQ0FBQ0EsQ0FBRixJQUFPLENBQUNBLENBQUMsQ0FBQ0MsTUFBZDtBQUFBLFdBUGMsQ0FBekI7O0FBUUEsY0FBSVQsYUFBSixFQUFtQjtBQUNqQixnQkFBSVQsU0FBUyxDQUFDUyxhQUFELEVBQWdCQyxZQUFoQixFQUE4QkMsZ0JBQTlCLENBQWIsRUFBOEQ7QUFDNURSLGNBQUFBLEtBQUssR0FBRyxJQUFSO0FBQ0FELGNBQUFBLE1BQU0sQ0FBQ00sRUFBRCxDQUFOLEdBQWE7QUFDWFcsZ0JBQUFBLE1BQU0sRUFBRWxCLFNBQVMsRUFBRVMsWUFBRiw0QkFBbUJDLGdCQUFuQjtBQUROLGVBQWI7QUFHRCxhQUxELE1BS08sSUFBSVIsS0FBSixFQUFXO0FBQ2hCQSxjQUFBQSxLQUFLLEdBQUcsS0FBUjtBQUNBRCxjQUFBQSxNQUFNLENBQUNNLEVBQUQsQ0FBTixHQUFhO0FBQ1hXLGdCQUFBQSxNQUFNLEVBQUU7QUFERyxlQUFiO0FBR0Q7QUFDRjtBQUNGLFNBeEJEO0FBeUJEOztBQUNELGFBQU9qQixNQUFQO0FBQ0Q7QUE5Q0ksR0FBUDtBQWdERCxDQXZERCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEVkZ2VTaWRlYmFyRGF0YSxcbiAgSGVhZGVyQ29uZmlnLFxuICBIZWFkZXJDb25maWdNYXAsXG4gIEluc2V0U2lkZWJhckRhdGEsXG4gIFJlc3VsdFN0eWxlLFxuICBTdWJoZWFkZXJEYXRhLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBjb21iaW5lQnJlYWtwb2ludHMsIHBpY2tOZWFyZXN0QnJlYWtwb2ludCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgKFxuICBzaWRlYmFyOlxuICAgIHwgUGljazxFZGdlU2lkZWJhckRhdGEsICdjb25maWdNYXBCeUlkJz5cbiAgICB8IFBpY2s8SW5zZXRTaWRlYmFyRGF0YSwgJ2NvbmZpZ01hcEJ5SWQnPixcbiAgaGVhZGVyOiBIZWFkZXJDb25maWdNYXAsXG4gIHN1YmhlYWRlcjogU3ViaGVhZGVyRGF0YVxuKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZ2V0UmVzdWx0U3R5bGU6IDxUPihcbiAgICAgIHNpZGViYXJJZDogc3RyaW5nLFxuICAgICAgcHJlZGljYXRlOiAoXG4gICAgICAgIHNpZGViYXJDb25maWc6IFQsXG4gICAgICAgIGhlYWRlckNvbmZpZzogSGVhZGVyQ29uZmlnLFxuICAgICAgICBzdWJoZWFkZXJDb25maWdzOiBIZWFkZXJDb25maWdbXVxuICAgICAgKSA9PiBib29sZWFuLFxuICAgICAgZ2V0SGVpZ2h0OiAoaGVhZGVyQ29uZmlnczogSGVhZGVyQ29uZmlnW10pID0+IHN0cmluZyB8IG51bWJlclxuICAgICkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0OiBSZXN1bHRTdHlsZSA9IHt9O1xuICAgICAgbGV0IGZvdW5kOiBib29sZWFuID0gZmFsc2U7XG4gICAgICBjb25zdCBjb25maWdNYXAgPSBzaWRlYmFyLmNvbmZpZ01hcEJ5SWRbc2lkZWJhcklkXTtcbiAgICAgIGlmIChjb25maWdNYXApIHtcbiAgICAgICAgY29uc3QgYnJlYWtwb2ludHMgPSBjb21iaW5lQnJlYWtwb2ludHMoXG4gICAgICAgICAgY29uZmlnTWFwLFxuICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICBzdWJoZWFkZXIuY29uZmlnTWFwXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrcG9pbnRzLmZvckVhY2goYnAgPT4ge1xuICAgICAgICAgIGNvbnN0IHNpZGViYXJDb25maWcgPSBwaWNrTmVhcmVzdEJyZWFrcG9pbnQ8VD4oY29uZmlnTWFwIGFzIGFueSwgYnApO1xuICAgICAgICAgIGNvbnN0IGhlYWRlckNvbmZpZyA9IHBpY2tOZWFyZXN0QnJlYWtwb2ludChoZWFkZXIsIGJwKTtcbiAgICAgICAgICBjb25zdCBzdWJoZWFkZXJDb25maWdzID0gT2JqZWN0LmtleXMoc3ViaGVhZGVyLmNvbmZpZ01hcEJ5SWQpXG4gICAgICAgICAgICAubWFwKHN1YmhlYWRlcklkID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBpY2tOZWFyZXN0QnJlYWtwb2ludChcbiAgICAgICAgICAgICAgICBzdWJoZWFkZXIuY29uZmlnTWFwQnlJZFtzdWJoZWFkZXJJZF0sXG4gICAgICAgICAgICAgICAgYnBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGMgPT4gISFjICYmICFjLmhpZGRlbik7XG4gICAgICAgICAgaWYgKHNpZGViYXJDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoc2lkZWJhckNvbmZpZywgaGVhZGVyQ29uZmlnLCBzdWJoZWFkZXJDb25maWdzKSkge1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc3VsdFticF0gPSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBnZXRIZWlnaHQoW2hlYWRlckNvbmZpZywgLi4uc3ViaGVhZGVyQ29uZmlnc10pLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXN1bHRbYnBdID0ge1xuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICB9O1xufTtcbiJdfQ==