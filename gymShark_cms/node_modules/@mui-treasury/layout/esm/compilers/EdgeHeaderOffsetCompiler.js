function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { isCollapsibleSidebarConfig } from '../utils/sidebarChecker';
import MultiHeadersEffect from '../effects/MultiHeaders';
import OffsetCompiler from './OffsetCompiler';
export default (function (edgeSidebar, header, subheader) {
  return {
    getResultStyle: function getResultStyle(sidebarId) {
      return OffsetCompiler(edgeSidebar, header, subheader).getResultStyle(sidebarId, function (sidebarConfig, headerConfig, subheaderConfigs) {
        return headerConfig && MultiHeadersEffect([headerConfig].concat(_toConsumableArray(subheaderConfigs))).getSidebarInteraction(sidebarId).isClipped && isCollapsibleSidebarConfig(sidebarConfig);
      }, function (headerConfigs) {
        return MultiHeadersEffect(headerConfigs).getSidebarInteraction(sidebarId).clippedHeight;
      });
    }
  };
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21waWxlcnMvRWRnZUhlYWRlck9mZnNldENvbXBpbGVyLnRzIl0sIm5hbWVzIjpbImlzQ29sbGFwc2libGVTaWRlYmFyQ29uZmlnIiwiTXVsdGlIZWFkZXJzRWZmZWN0IiwiT2Zmc2V0Q29tcGlsZXIiLCJlZGdlU2lkZWJhciIsImhlYWRlciIsInN1YmhlYWRlciIsImdldFJlc3VsdFN0eWxlIiwic2lkZWJhcklkIiwic2lkZWJhckNvbmZpZyIsImhlYWRlckNvbmZpZyIsInN1YmhlYWRlckNvbmZpZ3MiLCJnZXRTaWRlYmFySW50ZXJhY3Rpb24iLCJpc0NsaXBwZWQiLCJoZWFkZXJDb25maWdzIiwiY2xpcHBlZEhlaWdodCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBTUEsU0FBU0EsMEJBQVQsUUFBMkMseUJBQTNDO0FBQ0EsT0FBT0Msa0JBQVAsTUFBK0IseUJBQS9CO0FBQ0EsT0FBT0MsY0FBUCxNQUEyQixrQkFBM0I7QUFFQSxnQkFBZSxVQUNiQyxXQURhLEVBRWJDLE1BRmEsRUFHYkMsU0FIYSxFQUlWO0FBQ0gsU0FBTztBQUNMQyxJQUFBQSxjQUFjLEVBQUUsd0JBQUNDLFNBQUQ7QUFBQSxhQUNkTCxjQUFjLENBQUNDLFdBQUQsRUFBY0MsTUFBZCxFQUFzQkMsU0FBdEIsQ0FBZCxDQUErQ0MsY0FBL0MsQ0FHRUMsU0FIRixFQUlFLFVBQUNDLGFBQUQsRUFBZ0JDLFlBQWhCLEVBQThCQyxnQkFBOUIsRUFBbUQ7QUFDakQsZUFDRUQsWUFBWSxJQUNaUixrQkFBa0IsRUFDaEJRLFlBRGdCLDRCQUViQyxnQkFGYSxHQUFsQixDQUdHQyxxQkFISCxDQUd5QkosU0FIekIsRUFHb0NLLFNBSnBDLElBS0FaLDBCQUEwQixDQUFDUSxhQUFELENBTjVCO0FBUUQsT0FiSCxFQWNFLFVBQUFLLGFBQWE7QUFBQSxlQUNYWixrQkFBa0IsQ0FBQ1ksYUFBRCxDQUFsQixDQUFrQ0YscUJBQWxDLENBQXdESixTQUF4RCxFQUNHTyxhQUZRO0FBQUEsT0FkZixDQURjO0FBQUE7QUFEWCxHQUFQO0FBcUJELENBMUJEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRWRnZVNpZGViYXJDb25maWcsXG4gIEVkZ2VTaWRlYmFyRGF0YSxcbiAgSGVhZGVyQ29uZmlnTWFwLFxuICBTdWJoZWFkZXJEYXRhLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc0NvbGxhcHNpYmxlU2lkZWJhckNvbmZpZyB9IGZyb20gJy4uL3V0aWxzL3NpZGViYXJDaGVja2VyJztcbmltcG9ydCBNdWx0aUhlYWRlcnNFZmZlY3QgZnJvbSAnLi4vZWZmZWN0cy9NdWx0aUhlYWRlcnMnO1xuaW1wb3J0IE9mZnNldENvbXBpbGVyIGZyb20gJy4vT2Zmc2V0Q29tcGlsZXInO1xuXG5leHBvcnQgZGVmYXVsdCAoXG4gIGVkZ2VTaWRlYmFyOiBQaWNrPEVkZ2VTaWRlYmFyRGF0YSwgJ2NvbmZpZ01hcEJ5SWQnPixcbiAgaGVhZGVyOiBIZWFkZXJDb25maWdNYXAsXG4gIHN1YmhlYWRlcjogU3ViaGVhZGVyRGF0YVxuKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZ2V0UmVzdWx0U3R5bGU6IChzaWRlYmFySWQ6IHN0cmluZykgPT5cbiAgICAgIE9mZnNldENvbXBpbGVyKGVkZ2VTaWRlYmFyLCBoZWFkZXIsIHN1YmhlYWRlcikuZ2V0UmVzdWx0U3R5bGU8XG4gICAgICAgIEVkZ2VTaWRlYmFyQ29uZmlnXG4gICAgICA+KFxuICAgICAgICBzaWRlYmFySWQsXG4gICAgICAgIChzaWRlYmFyQ29uZmlnLCBoZWFkZXJDb25maWcsIHN1YmhlYWRlckNvbmZpZ3MpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaGVhZGVyQ29uZmlnICYmXG4gICAgICAgICAgICBNdWx0aUhlYWRlcnNFZmZlY3QoW1xuICAgICAgICAgICAgICBoZWFkZXJDb25maWcsXG4gICAgICAgICAgICAgIC4uLnN1YmhlYWRlckNvbmZpZ3MsXG4gICAgICAgICAgICBdKS5nZXRTaWRlYmFySW50ZXJhY3Rpb24oc2lkZWJhcklkKS5pc0NsaXBwZWQgJiZcbiAgICAgICAgICAgIGlzQ29sbGFwc2libGVTaWRlYmFyQ29uZmlnKHNpZGViYXJDb25maWcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyQ29uZmlncyA9PlxuICAgICAgICAgIE11bHRpSGVhZGVyc0VmZmVjdChoZWFkZXJDb25maWdzKS5nZXRTaWRlYmFySW50ZXJhY3Rpb24oc2lkZWJhcklkKVxuICAgICAgICAgICAgLmNsaXBwZWRIZWlnaHRcbiAgICAgICksXG4gIH07XG59O1xuIl19