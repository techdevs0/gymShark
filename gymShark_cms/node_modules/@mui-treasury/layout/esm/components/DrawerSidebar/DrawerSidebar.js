function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React from 'react';
import cx from 'clsx';
import { makeStyles } from '@material-ui/core/styles';
import useTheme from '@material-ui/core/styles/useTheme';
import { SidebarProvider, SidebarConsumer, useWindowCtx } from '../../contexts';
import { useSidebar, useBreakpointConfig, useSidebarAutoCollapse } from '../../hooks';
import getEdgeHeaderOffset from '../EdgeHeaderOffset';
import { CLS, createDrawerVariant } from '../Shared/SharedSidebar';
import { generateStyledProxyCreator } from '../Shared/StyledProxy';
import { get, createBreakpointStyles, createHiddenStyles } from '../../utils';
import { transitionStyles } from '../../styles';
import Drawer from '@material-ui/core/Drawer/Drawer';
export default (function (styled) {
  var styledProxy = generateStyledProxyCreator(styled);
  var StyledDrawer = styledProxy(Drawer, CLS);
  var EdgeHeaderOffset = getEdgeHeaderOffset(styled);
  var TemporaryDrawer = createDrawerVariant('temporary', StyledDrawer);
  var PermanentDrawer = createDrawerVariant('permanent', StyledDrawer);
  var PersistentDrawer = createDrawerVariant('persistent', StyledDrawer);
  var useTransitionStyles = makeStyles(transitionStyles);

  var DrawerSidebar = function DrawerSidebar(_ref) {
    var sidebarId = _ref.sidebarId,
        onClose = _ref.onClose,
        children = _ref.children,
        PaperProps = _ref.PaperProps,
        ModalProps = _ref.ModalProps,
        SlideProps = _ref.SlideProps,
        props = _objectWithoutProperties(_ref, ["sidebarId", "onClose", "children", "PaperProps", "ModalProps", "SlideProps"]);

    useSidebarAutoCollapse(sidebarId);

    var _useWindowCtx = useWindowCtx(),
        iDocument = _useWindowCtx.iDocument;

    var transition = useTransitionStyles();
    var theme = useTheme();
    var breakpoints = theme.breakpoints;

    var _useSidebar = useSidebar(sidebarId, 'DrawerSidebar'),
        anchor = _useSidebar.anchor,
        edgeSidebar = _useSidebar.edgeSidebar,
        _useSidebar$styles = _useSidebar.styles,
        permanent = _useSidebar$styles.permanent,
        persistent = _useSidebar$styles.persistent,
        temporary = _useSidebar$styles.temporary,
        state = _useSidebar.state,
        setOpen = _useSidebar.setOpen;

    var wrappedOnClose = function wrappedOnClose() {
      if (typeof onClose === 'function') onClose.apply(void 0, arguments);
      setOpen(sidebarId, false);
    };

    var config = useBreakpointConfig(edgeSidebar.configMapById[sidebarId]);
    var headerAdjustment = /*#__PURE__*/React.createElement(EdgeHeaderOffset, {
      sidebarId: sidebarId
    });
    return /*#__PURE__*/React.createElement(SidebarProvider, {
      id: sidebarId,
      config: config,
      sidebarState: state
    }, /*#__PURE__*/React.createElement(SidebarConsumer, null, function (_ref2) {
      var entered = _ref2.entered,
          inlineStyle = _ref2.inlineStyle,
          wrapOnEntered = _ref2.wrapOnEntered,
          wrapOnExit = _ref2.wrapOnExit,
          wrapOnMouseEnter = _ref2.wrapOnMouseEnter,
          wrapOnMouseLeave = _ref2.wrapOnMouseLeave;

      var commonProps = _extends(_extends({}, props), {}, {
        PaperProps: _extends(_extends({}, PaperProps), {}, {
          style: _extends(_extends({}, get(PaperProps, 'style')), inlineStyle),
          className: cx((entered || get(config, 'variant') === 'permanent') && transition.root, get(PaperProps, 'className')),
          onMouseEnter: wrapOnMouseEnter(PaperProps),
          onMouseLeave: wrapOnMouseLeave(PaperProps)
        }),
        ModalProps: _extends({
          container: iDocument ? iDocument.body : undefined
        }, ModalProps),
        SlideProps: _extends(_extends({}, SlideProps), {}, {
          onEntered: wrapOnEntered(SlideProps),
          onExit: wrapOnExit(SlideProps)
        }),
        anchor: anchor,
        open: state.open,
        onClose: wrappedOnClose
      });

      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TemporaryDrawer, _extends({
        disableScrollLock: true
      }, commonProps, {
        hiddenStyles: createHiddenStyles(temporary, [permanent, persistent], breakpoints),
        styles: createBreakpointStyles(temporary, theme)
      }), children), /*#__PURE__*/React.createElement(PersistentDrawer, _extends({}, commonProps, {
        hiddenStyles: createHiddenStyles(persistent, [temporary, permanent], breakpoints),
        styles: createBreakpointStyles(persistent, theme)
      }), headerAdjustment, children), /*#__PURE__*/React.createElement(PermanentDrawer, _extends({}, commonProps, {
        hiddenStyles: createHiddenStyles(permanent, [temporary, persistent], breakpoints),
        styles: createBreakpointStyles(permanent, theme)
      }), headerAdjustment, children));
    }));
  };

  return DrawerSidebar;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0RyYXdlclNpZGViYXIvRHJhd2VyU2lkZWJhci50c3giXSwibmFtZXMiOlsiUmVhY3QiLCJjeCIsIm1ha2VTdHlsZXMiLCJ1c2VUaGVtZSIsIlNpZGViYXJQcm92aWRlciIsIlNpZGViYXJDb25zdW1lciIsInVzZVdpbmRvd0N0eCIsInVzZVNpZGViYXIiLCJ1c2VCcmVha3BvaW50Q29uZmlnIiwidXNlU2lkZWJhckF1dG9Db2xsYXBzZSIsImdldEVkZ2VIZWFkZXJPZmZzZXQiLCJDTFMiLCJjcmVhdGVEcmF3ZXJWYXJpYW50IiwiZ2VuZXJhdGVTdHlsZWRQcm94eUNyZWF0b3IiLCJnZXQiLCJjcmVhdGVCcmVha3BvaW50U3R5bGVzIiwiY3JlYXRlSGlkZGVuU3R5bGVzIiwidHJhbnNpdGlvblN0eWxlcyIsIkRyYXdlciIsInN0eWxlZCIsInN0eWxlZFByb3h5IiwiU3R5bGVkRHJhd2VyIiwiRWRnZUhlYWRlck9mZnNldCIsIlRlbXBvcmFyeURyYXdlciIsIlBlcm1hbmVudERyYXdlciIsIlBlcnNpc3RlbnREcmF3ZXIiLCJ1c2VUcmFuc2l0aW9uU3R5bGVzIiwiRHJhd2VyU2lkZWJhciIsInNpZGViYXJJZCIsIm9uQ2xvc2UiLCJjaGlsZHJlbiIsIlBhcGVyUHJvcHMiLCJNb2RhbFByb3BzIiwiU2xpZGVQcm9wcyIsInByb3BzIiwiaURvY3VtZW50IiwidHJhbnNpdGlvbiIsInRoZW1lIiwiYnJlYWtwb2ludHMiLCJhbmNob3IiLCJlZGdlU2lkZWJhciIsInN0eWxlcyIsInBlcm1hbmVudCIsInBlcnNpc3RlbnQiLCJ0ZW1wb3JhcnkiLCJzdGF0ZSIsInNldE9wZW4iLCJ3cmFwcGVkT25DbG9zZSIsImNvbmZpZyIsImNvbmZpZ01hcEJ5SWQiLCJoZWFkZXJBZGp1c3RtZW50IiwiZW50ZXJlZCIsImlubGluZVN0eWxlIiwid3JhcE9uRW50ZXJlZCIsIndyYXBPbkV4aXQiLCJ3cmFwT25Nb3VzZUVudGVyIiwid3JhcE9uTW91c2VMZWF2ZSIsImNvbW1vblByb3BzIiwic3R5bGUiLCJjbGFzc05hbWUiLCJyb290Iiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwiY29udGFpbmVyIiwiYm9keSIsInVuZGVmaW5lZCIsIm9uRW50ZXJlZCIsIm9uRXhpdCIsIm9wZW4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE9BQU9BLEtBQVAsTUFBa0IsT0FBbEI7QUFDQSxPQUFPQyxFQUFQLE1BQWUsTUFBZjtBQUNBLFNBQVNDLFVBQVQsUUFBMkIsMEJBQTNCO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQixtQ0FBckI7QUFFQSxTQUFTQyxlQUFULEVBQTBCQyxlQUExQixFQUEyQ0MsWUFBM0MsUUFBK0QsZ0JBQS9EO0FBQ0EsU0FDRUMsVUFERixFQUVFQyxtQkFGRixFQUdFQyxzQkFIRixRQUlPLGFBSlA7QUFLQSxPQUFPQyxtQkFBUCxNQUFnQyxxQkFBaEM7QUFDQSxTQUFTQyxHQUFULEVBQWNDLG1CQUFkLFFBQXlDLHlCQUF6QztBQUNBLFNBQVNDLDBCQUFULFFBQTJDLHVCQUEzQztBQUNBLFNBQVNDLEdBQVQsRUFBY0Msc0JBQWQsRUFBc0NDLGtCQUF0QyxRQUFnRSxhQUFoRTtBQUNBLFNBQVNDLGdCQUFULFFBQWlDLGNBQWpDO0FBRUEsT0FBT0MsTUFBUCxNQUFtQixpQ0FBbkI7QUFFQSxnQkFBZSxVQUFDQyxNQUFELEVBQWlCO0FBQzlCLE1BQU1DLFdBQVcsR0FBR1AsMEJBQTBCLENBQUNNLE1BQUQsQ0FBOUM7QUFDQSxNQUFNRSxZQUFZLEdBQUdELFdBQVcsQ0FBY0YsTUFBZCxFQUFzQlAsR0FBdEIsQ0FBaEM7QUFDQSxNQUFNVyxnQkFBZ0IsR0FBR1osbUJBQW1CLENBQUNTLE1BQUQsQ0FBNUM7QUFFQSxNQUFNSSxlQUFlLEdBQUdYLG1CQUFtQixDQUFDLFdBQUQsRUFBY1MsWUFBZCxDQUEzQztBQUNBLE1BQU1HLGVBQWUsR0FBR1osbUJBQW1CLENBQUMsV0FBRCxFQUFjUyxZQUFkLENBQTNDO0FBQ0EsTUFBTUks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O0FBT0UsUUFBQSxNQUFNLEVBQUV2QixzQkFBc0IsQ0FBQzJCLFNBQUQsRUFBWUwsS0FBWjtBQVBoQyxVQVNHYSxnQkFUSCxFQVVHcEIsUUFWSCxDQXpCRixDQURGO0FBd0NELEtBOUVILENBREYsQ0FERjtBQW9GRCxHQXJIRDs7QUF1SEEsU0FBT0gsYUFBUDtBQUNELENBbklEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjeCBmcm9tICdjbHN4JztcbmltcG9ydCB7IG1ha2VTdHlsZXMgfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9zdHlsZXMnO1xuaW1wb3J0IHVzZVRoZW1lIGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL3N0eWxlcy91c2VUaGVtZSc7XG5pbXBvcnQgeyBEcmF3ZXJQcm9wcyB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL0RyYXdlcic7XG5pbXBvcnQgeyBTaWRlYmFyUHJvdmlkZXIsIFNpZGViYXJDb25zdW1lciwgdXNlV2luZG93Q3R4IH0gZnJvbSAnLi4vLi4vY29udGV4dHMnO1xuaW1wb3J0IHtcbiAgdXNlU2lkZWJhcixcbiAgdXNlQnJlYWtwb2ludENvbmZpZyxcbiAgdXNlU2lkZWJhckF1dG9Db2xsYXBzZSxcbn0gZnJvbSAnLi4vLi4vaG9va3MnO1xuaW1wb3J0IGdldEVkZ2VIZWFkZXJPZmZzZXQgZnJvbSAnLi4vRWRnZUhlYWRlck9mZnNldCc7XG5pbXBvcnQgeyBDTFMsIGNyZWF0ZURyYXdlclZhcmlhbnQgfSBmcm9tICcuLi9TaGFyZWQvU2hhcmVkU2lkZWJhcic7XG5pbXBvcnQgeyBnZW5lcmF0ZVN0eWxlZFByb3h5Q3JlYXRvciB9IGZyb20gJy4uL1NoYXJlZC9TdHlsZWRQcm94eSc7XG5pbXBvcnQgeyBnZXQsIGNyZWF0ZUJyZWFrcG9pbnRTdHlsZXMsIGNyZWF0ZUhpZGRlblN0eWxlcyB9IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IHRyYW5zaXRpb25TdHlsZXMgfSBmcm9tICcuLi8uLi9zdHlsZXMnO1xuaW1wb3J0IHsgRWRnZVNpZGViYXJDb25maWcgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgRHJhd2VyIGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL0RyYXdlci9EcmF3ZXInO1xuXG5leHBvcnQgZGVmYXVsdCAoc3R5bGVkOiBhbnkpID0+IHtcbiAgY29uc3Qgc3R5bGVkUHJveHkgPSBnZW5lcmF0ZVN0eWxlZFByb3h5Q3JlYXRvcihzdHlsZWQpO1xuICBjb25zdCBTdHlsZWREcmF3ZXIgPSBzdHlsZWRQcm94eTxEcmF3ZXJQcm9wcz4oRHJhd2VyLCBDTFMpO1xuICBjb25zdCBFZGdlSGVhZGVyT2Zmc2V0ID0gZ2V0RWRnZUhlYWRlck9mZnNldChzdHlsZWQpO1xuXG4gIGNvbnN0IFRlbXBvcmFyeURyYXdlciA9IGNyZWF0ZURyYXdlclZhcmlhbnQoJ3RlbXBvcmFyeScsIFN0eWxlZERyYXdlcik7XG4gIGNvbnN0IFBlcm1hbmVudERyYXdlciA9IGNyZWF0ZURyYXdlclZhcmlhbnQoJ3Blcm1hbmVudCcsIFN0eWxlZERyYXdlcik7XG4gIGNvbnN0IFBlcnNpc3RlbnREcmF3ZXIgPSBjcmVhdGVEcmF3ZXJWYXJpYW50KCdwZXJzaXN0ZW50JywgU3R5bGVkRHJhd2VyKTtcblxuICBjb25zdCB1c2VUcmFuc2l0aW9uU3R5bGVzID0gbWFrZVN0eWxlcyh0cmFuc2l0aW9uU3R5bGVzKTtcblxuICBjb25zdCBEcmF3ZXJTaWRlYmFyID0gKHtcbiAgICBzaWRlYmFySWQsXG4gICAgb25DbG9zZSxcbiAgICBjaGlsZHJlbixcbiAgICBQYXBlclByb3BzLFxuICAgIE1vZGFsUHJvcHMsXG4gICAgU2xpZGVQcm9wcyxcbiAgICAuLi5wcm9wc1xuICB9OiBPbWl0PERyYXdlclByb3BzLCAndmFyaWFudCc+ICYge1xuICAgIHNpZGViYXJJZDogc3RyaW5nO1xuICB9KSA9PiB7XG4gICAgdXNlU2lkZWJhckF1dG9Db2xsYXBzZShzaWRlYmFySWQpO1xuICAgIGNvbnN0IHsgaURvY3VtZW50IH0gPSB1c2VXaW5kb3dDdHgoKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvblN0eWxlcygpO1xuICAgIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgICBjb25zdCB7IGJyZWFrcG9pbnRzIH0gPSB0aGVtZTtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3IsXG4gICAgICBlZGdlU2lkZWJhcixcbiAgICAgIHN0eWxlczogeyBwZXJtYW5lbnQsIHBlcnNpc3RlbnQsIHRlbXBvcmFyeSB9LFxuICAgICAgc3RhdGUsXG4gICAgICBzZXRPcGVuLFxuICAgIH0gPSB1c2VTaWRlYmFyKHNpZGViYXJJZCwgJ0RyYXdlclNpZGViYXInKTtcbiAgICBjb25zdCB3cmFwcGVkT25DbG9zZTogRHJhd2VyUHJvcHNbJ29uQ2xvc2UnXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9uQ2xvc2UgPT09ICdmdW5jdGlvbicpIG9uQ2xvc2UoLi4uYXJncyk7XG4gICAgICBzZXRPcGVuKHNpZGViYXJJZCwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgY29uZmlnID0gdXNlQnJlYWtwb2ludENvbmZpZzxFZGdlU2lkZWJhckNvbmZpZz4oXG4gICAgICBlZGdlU2lkZWJhci5jb25maWdNYXBCeUlkW3NpZGViYXJJZF1cbiAgICApO1xuXG4gICAgY29uc3QgaGVhZGVyQWRqdXN0bWVudCA9IDxFZGdlSGVhZGVyT2Zmc2V0IHNpZGViYXJJZD17c2lkZWJhcklkfSAvPjtcblxuICAgIHJldHVybiAoXG4gICAgICA8U2lkZWJhclByb3ZpZGVyIGlkPXtzaWRlYmFySWR9IGNvbmZpZz17Y29uZmlnfSBzaWRlYmFyU3RhdGU9e3N0YXRlfT5cbiAgICAgICAgPFNpZGViYXJDb25zdW1lcj5cbiAgICAgICAgICB7KHtcbiAgICAgICAgICAgIGVudGVyZWQsXG4gICAgICAgICAgICBpbmxpbmVTdHlsZSxcbiAgICAgICAgICAgIHdyYXBPbkVudGVyZWQsXG4gICAgICAgICAgICB3cmFwT25FeGl0LFxuICAgICAgICAgICAgd3JhcE9uTW91c2VFbnRlcixcbiAgICAgICAgICAgIHdyYXBPbk1vdXNlTGVhdmUsXG4gICAgICAgICAgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tbW9uUHJvcHMgPSB7XG4gICAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgICBQYXBlclByb3BzOiB7XG4gICAgICAgICAgICAgICAgLi4uUGFwZXJQcm9wcyxcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgLi4uZ2V0KFBhcGVyUHJvcHMsICdzdHlsZScpLFxuICAgICAgICAgICAgICAgICAgLi4uaW5saW5lU3R5bGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGN4KFxuICAgICAgICAgICAgICAgICAgKGVudGVyZWQgfHwgZ2V0KGNvbmZpZywgJ3ZhcmlhbnQnKSA9PT0gJ3Blcm1hbmVudCcpICYmXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb24ucm9vdCxcbiAgICAgICAgICAgICAgICAgIGdldChQYXBlclByb3BzLCAnY2xhc3NOYW1lJylcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcjogd3JhcE9uTW91c2VFbnRlcihQYXBlclByb3BzKSxcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU6IHdyYXBPbk1vdXNlTGVhdmUoUGFwZXJQcm9wcyksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIE1vZGFsUHJvcHM6IHtcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGlEb2N1bWVudCA/IGlEb2N1bWVudC5ib2R5IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC4uLk1vZGFsUHJvcHMsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFNsaWRlUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAuLi5TbGlkZVByb3BzLFxuICAgICAgICAgICAgICAgIG9uRW50ZXJlZDogd3JhcE9uRW50ZXJlZChTbGlkZVByb3BzKSxcbiAgICAgICAgICAgICAgICBvbkV4aXQ6IHdyYXBPbkV4aXQoU2xpZGVQcm9wcyksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgICAgb3Blbjogc3RhdGUub3BlbixcbiAgICAgICAgICAgICAgb25DbG9zZTogd3JhcHBlZE9uQ2xvc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8VGVtcG9yYXJ5RHJhd2VyXG4gICAgICAgICAgICAgICAgICBkaXNhYmxlU2Nyb2xsTG9ja1xuICAgICAgICAgICAgICAgICAgey4uLmNvbW1vblByb3BzfVxuICAgICAgICAgICAgICAgICAgaGlkZGVuU3R5bGVzPXtjcmVhdGVIaWRkZW5TdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgIHRlbXBvcmFyeSxcbiAgICAgICAgICAgICAgICAgICAgW3Blcm1hbmVudCwgcGVyc2lzdGVudF0sXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzXG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgc3R5bGVzPXtjcmVhdGVCcmVha3BvaW50U3R5bGVzKHRlbXBvcmFyeSwgdGhlbWUpfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICA8L1RlbXBvcmFyeURyYXdlcj5cbiAgICAgICAgICAgICAgICA8UGVyc2lzdGVudERyYXdlclxuICAgICAgICAgICAgICAgICAgey4uLmNvbW1vblByb3BzfVxuICAgICAgICAgICAgICAgICAgaGlkZGVuU3R5bGVzPXtjcmVhdGVIaWRkZW5TdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlbnQsXG4gICAgICAgICAgICAgICAgICAgIFt0ZW1wb3JhcnksIHBlcm1hbmVudF0sXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzXG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgc3R5bGVzPXtjcmVhdGVCcmVha3BvaW50U3R5bGVzKHBlcnNpc3RlbnQsIHRoZW1lKX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7aGVhZGVyQWRqdXN0bWVudH1cbiAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICA8L1BlcnNpc3RlbnREcmF3ZXI+XG4gICAgICAgICAgICAgICAgPFBlcm1hbmVudERyYXdlclxuICAgICAgICAgICAgICAgICAgey4uLmNvbW1vblByb3BzfVxuICAgICAgICAgICAgICAgICAgaGlkZGVuU3R5bGVzPXtjcmVhdGVIaWRkZW5TdHlsZXMoXG4gICAgICAgICAgICAgICAgICAgIHBlcm1hbmVudCxcbiAgICAgICAgICAgICAgICAgICAgW3RlbXBvcmFyeSwgcGVyc2lzdGVudF0sXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzXG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgc3R5bGVzPXtjcmVhdGVCcmVha3BvaW50U3R5bGVzKHBlcm1hbmVudCwgdGhlbWUpfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtoZWFkZXJBZGp1c3RtZW50fVxuICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgIDwvUGVybWFuZW50RHJhd2VyPlxuICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfX1cbiAgICAgICAgPC9TaWRlYmFyQ29uc3VtZXI+XG4gICAgICA8L1NpZGViYXJQcm92aWRlcj5cbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBEcmF3ZXJTaWRlYmFyO1xufTtcbiJdfQ==