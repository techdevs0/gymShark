function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from 'react';
import cx from 'clsx';
import { makeStyles, useTheme } from '@material-ui/core/styles';
import { useLayoutCtx } from '../../contexts';
import { generateStyledProxyCreator } from '../Shared/StyledProxy';
import InsetHeaderOffsetCompiler from '../../compilers/InsetHeaderOffsetCompiler';
import { createBreakpointStyles } from '../../utils';
import { useInsetHeaderMagnet } from '../../hooks/useInsetHeaderMagnet';
import { transitionStyles } from '../../styles';
export default (function (styled) {
  var styledProxy = generateStyledProxyCreator(styled);
  var Div = styledProxy('div');
  var useTransitionStyles = makeStyles(transitionStyles);

  var InsetHeaderOffset = function InsetHeaderOffset(_ref) {
    var sidebarId = _ref.sidebarId;
    var theme = useTheme();
    var transition = useTransitionStyles();

    var _useLayoutCtx = useLayoutCtx(),
        data = _useLayoutCtx.data;

    var compiler = InsetHeaderOffsetCompiler(data.insetSidebar, data.header, data.subheader);
    var styles = createBreakpointStyles(compiler.getResultStyle(sidebarId), theme);
    var inlineStyle = useInsetHeaderMagnet(sidebarId);
    return /*#__PURE__*/React.createElement(Div, {
      className: cx('InsetHeaderOffset', transition.smooth),
      styles: _extends(_extends({}, styles), {}, {
        flexShrink: 0
      }),
      style: inlineStyle
    });
  };

  return InsetHeaderOffset;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0luc2V0SGVhZGVyT2Zmc2V0L0luc2V0SGVhZGVyT2Zmc2V0LnRzeCJdLCJuYW1lcyI6WyJSZWFjdCIsImN4IiwibWFrZVN0eWxlcyIsInVzZVRoZW1lIiwidXNlTGF5b3V0Q3R4IiwiZ2VuZXJhdGVTdHlsZWRQcm94eUNyZWF0b3IiLCJJbnNldEhlYWRlck9mZnNldENvbXBpbGVyIiwiY3JlYXRlQnJlYWtwb2ludFN0eWxlcyIsInVzZUluc2V0SGVhZGVyTWFnbmV0IiwidHJhbnNpdGlvblN0eWxlcyIsInN0eWxlZCIsInN0eWxlZFByb3h5IiwiRGl2IiwidXNlVHJhbnNpdGlvblN0eWxlcyIsIkluc2V0SGVhZGVyT2Zmc2V0Iiwic2lkZWJhcklkIiwidGhlbWUiLCJ0cmFuc2l0aW9uIiwiZGF0YSIsImNvbXBpbGVyIiwiaW5zZXRTaWRlYmFyIiwiaGVhZGVyIiwic3ViaGVhZGVyIiwic3R5bGVzIiwiZ2V0UmVzdWx0U3R5bGUiLCJpbmxpbmVTdHlsZSIsInNtb290aCIsImZsZXhTaHJpbmsiXSwibWFwcGluZ3MiOiI7O0FBQUEsT0FBT0EsS0FBUCxNQUFrQixPQUFsQjtBQUNBLE9BQU9DLEVBQVAsTUFBZSxNQUFmO0FBQ0EsU0FBU0MsVUFBVCxFQUFxQkMsUUFBckIsUUFBcUMsMEJBQXJDO0FBQ0EsU0FBU0MsWUFBVCxRQUE2QixnQkFBN0I7QUFDQSxTQUFTQywwQkFBVCxRQUEyQyx1QkFBM0M7QUFDQSxPQUFPQyx5QkFBUCxNQUFzQywyQ0FBdEM7QUFDQSxTQUFTQyxzQkFBVCxRQUF1QyxhQUF2QztBQUNBLFNBQVNDLG9CQUFULFFBQXFDLGtDQUFyQztBQUNBLFNBQVNDLGdCQUFULFFBQWlDLGNBQWpDO0FBRUEsZ0JBQWUsVUFBQ0MsTUFBRCxFQUFpQjtBQUM5QixNQUFNQyxXQUFXLEdBQUdOLDBCQUEwQixDQUFDSyxNQUFELENBQTlDO0FBQ0EsTUFBTUUsR0FBRyxHQUFHRCxXQUFXLENBQUMsS0FBRCxDQUF2QjtBQUVBLE1BQU1FLG1CQUFtQixHQUFHWCxVQUFVLENBQUNPLGdCQUFELENBQXRDOztBQUVBLE1BQU1LLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBb0IsT0FBMEM7QUFBQSxRQUF2Q0MsU0FBdUMsUUFBdkNBLFNBQXVDO0FBQ2xFLFFBQU1DLEtBQUssR0FBR2IsUUFBUSxFQUF0QjtBQUNBLFFBQU1jLFVBQVUsR0FBR0osbUJBQW1CLEVBQXRDOztBQUZrRSx3QkFHakRULFlBQVksRUFIcUM7QUFBQSxRQUcxRGMsSUFIMEQsaUJBRzFEQSxJQUgwRDs7QUFJbEUsUUFBTUMsUUFBUSxHQUFHYix5QkFBeUIsQ0FDeENZLElBQUksQ0FBQ0UsWUFEbUMsRUFFeENGLElBQUksQ0FBQ0csTUFGbUMsRUFHeENILElBQUksQ0FBQ0ksU0FIbUMsQ0FBMUM7QUFLQSxRQUFNQyxNQUFNLEdBQUdoQixzQkFBc0IsQ0FDbkNZLFFBQVEsQ0FBQ0ssY0FBVCxDQUF3QlQsU0FBeEIsQ0FEbUMsRUFFbkNDLEtBRm1DLENBQXJDO0FBSUEsUUFBTVMsV0FBVyxHQUFHakIsb0JBQW9CLENBQUNPLFNBQUQsQ0FBeEM7QUFDQSx3QkFDRSxvQkFBQyxHQUFEO0FBQ0UsTUFBQSxTQUFTLEVBQUVkLEVBQUUsQ0FBQyxtQkFBRCxFQUFzQmdCLFVBQVUsQ0FBQ1MsTUFBakMsQ0FEZjtBQUVFLE1BQUEsTUFBTSx3QkFBT0gsTUFBUDtBQUFlSSxRQUFBQSxVQUFVLEVBQUU7QUFBM0IsUUFGUjtBQUdFLE1BQUEsS0FBSyxFQUFFRjtBQUhULE1BREY7QUFPRCxHQXJCRDs7QUFzQkEsU0FBT1gsaUJBQVA7QUFDRCxDQTdCRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBtYWtlU3R5bGVzLCB1c2VUaGVtZSB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL3N0eWxlcyc7XG5pbXBvcnQgeyB1c2VMYXlvdXRDdHggfSBmcm9tICcuLi8uLi9jb250ZXh0cyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVN0eWxlZFByb3h5Q3JlYXRvciB9IGZyb20gJy4uL1NoYXJlZC9TdHlsZWRQcm94eSc7XG5pbXBvcnQgSW5zZXRIZWFkZXJPZmZzZXRDb21waWxlciBmcm9tICcuLi8uLi9jb21waWxlcnMvSW5zZXRIZWFkZXJPZmZzZXRDb21waWxlcic7XG5pbXBvcnQgeyBjcmVhdGVCcmVha3BvaW50U3R5bGVzIH0gZnJvbSAnLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgdXNlSW5zZXRIZWFkZXJNYWduZXQgfSBmcm9tICcuLi8uLi9ob29rcy91c2VJbnNldEhlYWRlck1hZ25ldCc7XG5pbXBvcnQgeyB0cmFuc2l0aW9uU3R5bGVzIH0gZnJvbSAnLi4vLi4vc3R5bGVzJztcblxuZXhwb3J0IGRlZmF1bHQgKHN0eWxlZDogYW55KSA9PiB7XG4gIGNvbnN0IHN0eWxlZFByb3h5ID0gZ2VuZXJhdGVTdHlsZWRQcm94eUNyZWF0b3Ioc3R5bGVkKTtcbiAgY29uc3QgRGl2ID0gc3R5bGVkUHJveHkoJ2RpdicpO1xuXG4gIGNvbnN0IHVzZVRyYW5zaXRpb25TdHlsZXMgPSBtYWtlU3R5bGVzKHRyYW5zaXRpb25TdHlsZXMpO1xuXG4gIGNvbnN0IEluc2V0SGVhZGVyT2Zmc2V0ID0gKHsgc2lkZWJhcklkIH06IHsgc2lkZWJhcklkOiBzdHJpbmcgfSkgPT4ge1xuICAgIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvblN0eWxlcygpO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gdXNlTGF5b3V0Q3R4KCk7XG4gICAgY29uc3QgY29tcGlsZXIgPSBJbnNldEhlYWRlck9mZnNldENvbXBpbGVyKFxuICAgICAgZGF0YS5pbnNldFNpZGViYXIsXG4gICAgICBkYXRhLmhlYWRlcixcbiAgICAgIGRhdGEuc3ViaGVhZGVyXG4gICAgKTtcbiAgICBjb25zdCBzdHlsZXMgPSBjcmVhdGVCcmVha3BvaW50U3R5bGVzKFxuICAgICAgY29tcGlsZXIuZ2V0UmVzdWx0U3R5bGUoc2lkZWJhcklkKSxcbiAgICAgIHRoZW1lXG4gICAgKTtcbiAgICBjb25zdCBpbmxpbmVTdHlsZSA9IHVzZUluc2V0SGVhZGVyTWFnbmV0KHNpZGViYXJJZCk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxEaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjeCgnSW5zZXRIZWFkZXJPZmZzZXQnLCB0cmFuc2l0aW9uLnNtb290aCl9XG4gICAgICAgIHN0eWxlcz17eyAuLi5zdHlsZXMsIGZsZXhTaHJpbms6IDAgfX1cbiAgICAgICAgc3R5bGU9e2lubGluZVN0eWxlfVxuICAgICAgLz5cbiAgICApO1xuICB9O1xuICByZXR1cm4gSW5zZXRIZWFkZXJPZmZzZXQ7XG59O1xuIl19