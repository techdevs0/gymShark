function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React from 'react';
import cx from 'clsx';
import { makeStyles, useTheme } from '@material-ui/core/styles';
import { useLayoutCtx } from '../../contexts';
import EdgeHeaderOffsetCompiler from '../../compilers/EdgeHeaderOffsetCompiler';
import { useEdgeHeaderMagnet } from '../../hooks';
import { generateStyledProxyCreator } from '../Shared/StyledProxy';
import { transitionStyles } from '../../styles';
import { createBreakpointStyles } from '../../utils';
export default (function (styled) {
  var styledProxy = generateStyledProxyCreator(styled);
  var Div = styledProxy('div');
  var useTransitionStyles = makeStyles(transitionStyles);

  var EdgeHeaderOffset = function EdgeHeaderOffset(_ref) {
    var sidebarId = _ref.sidebarId;
    var theme = useTheme();
    var transition = useTransitionStyles();

    var _useLayoutCtx = useLayoutCtx(),
        data = _useLayoutCtx.data;

    var compiler = EdgeHeaderOffsetCompiler(data.edgeSidebar, data.header, data.subheader);
    var styles = createBreakpointStyles(compiler.getResultStyle(sidebarId), theme);
    var inlineStyle = useEdgeHeaderMagnet(sidebarId);
    return /*#__PURE__*/React.createElement(Div, {
      className: cx('EdgeHeaderOffset', transition.smooth),
      styles: _extends(_extends({}, styles), {}, {
        flexShrink: 0
      }),
      style: inlineStyle
    });
  };

  return EdgeHeaderOffset;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0VkZ2VIZWFkZXJPZmZzZXQvRWRnZUhlYWRlck9mZnNldC50c3giXSwibmFtZXMiOlsiUmVhY3QiLCJjeCIsIm1ha2VTdHlsZXMiLCJ1c2VUaGVtZSIsInVzZUxheW91dEN0eCIsIkVkZ2VIZWFkZXJPZmZzZXRDb21waWxlciIsInVzZUVkZ2VIZWFkZXJNYWduZXQiLCJnZW5lcmF0ZVN0eWxlZFByb3h5Q3JlYXRvciIsInRyYW5zaXRpb25TdHlsZXMiLCJjcmVhdGVCcmVha3BvaW50U3R5bGVzIiwic3R5bGVkIiwic3R5bGVkUHJveHkiLCJEaXYiLCJ1c2VUcmFuc2l0aW9uU3R5bGVzIiwiRWRnZUhlYWRlck9mZnNldCIsInNpZGViYXJJZCIsInRoZW1lIiwidHJhbnNpdGlvbiIsImRhdGEiLCJjb21waWxlciIsImVkZ2VTaWRlYmFyIiwiaGVhZGVyIiwic3ViaGVhZGVyIiwic3R5bGVzIiwiZ2V0UmVzdWx0U3R5bGUiLCJpbmxpbmVTdHlsZSIsInNtb290aCIsImZsZXhTaHJpbmsiXSwibWFwcGluZ3MiOiI7O0FBQUEsT0FBT0EsS0FBUCxNQUFrQixPQUFsQjtBQUNBLE9BQU9DLEVBQVAsTUFBZSxNQUFmO0FBQ0EsU0FBU0MsVUFBVCxFQUFxQkMsUUFBckIsUUFBcUMsMEJBQXJDO0FBQ0EsU0FBU0MsWUFBVCxRQUE2QixnQkFBN0I7QUFDQSxPQUFPQyx3QkFBUCxNQUFxQywwQ0FBckM7QUFDQSxTQUFTQyxtQkFBVCxRQUFvQyxhQUFwQztBQUNBLFNBQVNDLDBCQUFULFFBQTJDLHVCQUEzQztBQUNBLFNBQVNDLGdCQUFULFFBQWlDLGNBQWpDO0FBQ0EsU0FBU0Msc0JBQVQsUUFBdUMsYUFBdkM7QUFFQSxnQkFBZSxVQUFDQyxNQUFELEVBQWlCO0FBQzlCLE1BQU1DLFdBQVcsR0FBR0osMEJBQTBCLENBQUNHLE1BQUQsQ0FBOUM7QUFDQSxNQUFNRSxHQUFHLEdBQUdELFdBQVcsQ0FBQyxLQUFELENBQXZCO0FBRUEsTUFBTUUsbUJBQW1CLEdBQUdYLFVBQVUsQ0FBQ00sZ0JBQUQsQ0FBdEM7O0FBRUEsTUFBTU0sZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixPQUEwQztBQUFBLFFBQXZDQyxTQUF1QyxRQUF2Q0EsU0FBdUM7QUFDakUsUUFBTUMsS0FBSyxHQUFHYixRQUFRLEVBQXRCO0FBQ0EsUUFBTWMsVUFBVSxHQUFHSixtQkFBbUIsRUFBdEM7O0FBRmlFLHdCQUdoRFQsWUFBWSxFQUhvQztBQUFBLFFBR3pEYyxJQUh5RCxpQkFHekRBLElBSHlEOztBQUlqRSxRQUFNQyxRQUFRLEdBQUdkLHdCQUF3QixDQUN2Q2EsSUFBSSxDQUFDRSxXQURrQyxFQUV2Q0YsSUFBSSxDQUFDRyxNQUZrQyxFQUd2Q0gsSUFBSSxDQUFDSSxTQUhrQyxDQUF6QztBQUtBLFFBQU1DLE1BQU0sR0FBR2Qsc0JBQXNCLENBQ25DVSxRQUFRLENBQUNLLGNBQVQsQ0FBd0JULFNBQXhCLENBRG1DLEVBRW5DQyxLQUZtQyxDQUFyQztBQUlBLFFBQU1TLFdBQVcsR0FBR25CLG1CQUFtQixDQUFDUyxTQUFELENBQXZDO0FBQ0Esd0JBQ0Usb0JBQUMsR0FBRDtBQUNFLE1BQUEsU0FBUyxFQUFFZCxFQUFFLENBQUMsa0JBQUQsRUFBcUJnQixVQUFVLENBQUNTLE1BQWhDLENBRGY7QUFFRSxNQUFBLE1BQU0sd0JBQU9ILE1BQVA7QUFBZUksUUFBQUEsVUFBVSxFQUFFO0FBQTNCLFFBRlI7QUFHRSxNQUFBLEtBQUssRUFBRUY7QUFIVCxNQURGO0FBT0QsR0FyQkQ7O0FBc0JBLFNBQU9YLGdCQUFQO0FBQ0QsQ0E3QkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgbWFrZVN0eWxlcywgdXNlVGhlbWUgfSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9zdHlsZXMnO1xuaW1wb3J0IHsgdXNlTGF5b3V0Q3R4IH0gZnJvbSAnLi4vLi4vY29udGV4dHMnO1xuaW1wb3J0IEVkZ2VIZWFkZXJPZmZzZXRDb21waWxlciBmcm9tICcuLi8uLi9jb21waWxlcnMvRWRnZUhlYWRlck9mZnNldENvbXBpbGVyJztcbmltcG9ydCB7IHVzZUVkZ2VIZWFkZXJNYWduZXQgfSBmcm9tICcuLi8uLi9ob29rcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZVN0eWxlZFByb3h5Q3JlYXRvciB9IGZyb20gJy4uL1NoYXJlZC9TdHlsZWRQcm94eSc7XG5pbXBvcnQgeyB0cmFuc2l0aW9uU3R5bGVzIH0gZnJvbSAnLi4vLi4vc3R5bGVzJztcbmltcG9ydCB7IGNyZWF0ZUJyZWFrcG9pbnRTdHlsZXMgfSBmcm9tICcuLi8uLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IChzdHlsZWQ6IGFueSkgPT4ge1xuICBjb25zdCBzdHlsZWRQcm94eSA9IGdlbmVyYXRlU3R5bGVkUHJveHlDcmVhdG9yKHN0eWxlZCk7XG4gIGNvbnN0IERpdiA9IHN0eWxlZFByb3h5KCdkaXYnKTtcblxuICBjb25zdCB1c2VUcmFuc2l0aW9uU3R5bGVzID0gbWFrZVN0eWxlcyh0cmFuc2l0aW9uU3R5bGVzKTtcblxuICBjb25zdCBFZGdlSGVhZGVyT2Zmc2V0ID0gKHsgc2lkZWJhcklkIH06IHsgc2lkZWJhcklkOiBzdHJpbmcgfSkgPT4ge1xuICAgIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gdXNlVHJhbnNpdGlvblN0eWxlcygpO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gdXNlTGF5b3V0Q3R4KCk7XG4gICAgY29uc3QgY29tcGlsZXIgPSBFZGdlSGVhZGVyT2Zmc2V0Q29tcGlsZXIoXG4gICAgICBkYXRhLmVkZ2VTaWRlYmFyLFxuICAgICAgZGF0YS5oZWFkZXIsXG4gICAgICBkYXRhLnN1YmhlYWRlclxuICAgICk7XG4gICAgY29uc3Qgc3R5bGVzID0gY3JlYXRlQnJlYWtwb2ludFN0eWxlcyhcbiAgICAgIGNvbXBpbGVyLmdldFJlc3VsdFN0eWxlKHNpZGViYXJJZCksXG4gICAgICB0aGVtZVxuICAgICk7XG4gICAgY29uc3QgaW5saW5lU3R5bGUgPSB1c2VFZGdlSGVhZGVyTWFnbmV0KHNpZGViYXJJZCk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxEaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjeCgnRWRnZUhlYWRlck9mZnNldCcsIHRyYW5zaXRpb24uc21vb3RoKX1cbiAgICAgICAgc3R5bGVzPXt7IC4uLnN0eWxlcywgZmxleFNocmluazogMCB9fVxuICAgICAgICBzdHlsZT17aW5saW5lU3R5bGV9XG4gICAgICAvPlxuICAgICk7XG4gIH07XG4gIHJldHVybiBFZGdlSGVhZGVyT2Zmc2V0O1xufTtcbiJdfQ==