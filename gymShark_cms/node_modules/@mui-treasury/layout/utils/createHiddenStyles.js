"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.getHiddenRange = exports.isLowerBreakpointFromSibling = exports.combineSiblings = exports.sortBreakpoints = void 0;

var _createBreakpoints = require("@material-ui/core/styles/createBreakpoints");

var _createDisplayNone = _interopRequireDefault(require("./createDisplayNone"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var sortBreakpoints = function sortBreakpoints(breakpoints) {
  return breakpoints.sort(function (a, b) {
    return _createBreakpoints.keys.indexOf(a) - _createBreakpoints.keys.indexOf(b);
  });
};

exports.sortBreakpoints = sortBreakpoints;

var combineSiblings = function combineSiblings(siblings) {
  return siblings.reduce(function (result, curr) {
    return [].concat(_toConsumableArray(result), _toConsumableArray(Object.keys(curr)));
  }, []);
};

exports.combineSiblings = combineSiblings;

var isLowerBreakpointFromSibling = function isLowerBreakpointFromSibling(selfBreakpoints, siblingsBreakpoints, bp) {
  var keysUtilBreakpoint = _createBreakpoints.keys.slice(0, _createBreakpoints.keys.indexOf(bp));

  var isSibling = false;
  var isSelf = false;
  keysUtilBreakpoint.reverse().forEach(function (v) {
    if (!isSibling && !isSelf) {
      if (siblingsBreakpoints.includes(v)) {
        isSibling = true;
      }

      if (selfBreakpoints.includes(v)) {
        isSelf = true;
      }
    }
  });
  return isSibling;
};

exports.isLowerBreakpointFromSibling = isLowerBreakpointFromSibling;

var getHiddenRange = function getHiddenRange(self, siblings) {
  var selfBreakpoints = sortBreakpoints(Object.keys(self));
  var siblingsBreakpoints = sortBreakpoints(combineSiblings(siblings));
  var found = false;
  var result = [];

  _createBreakpoints.keys.forEach(function (bp) {
    if (selfBreakpoints.includes(bp) || siblingsBreakpoints.includes(bp)) {
      found = true; // logic continue

      if (selfBreakpoints.includes(bp) && siblingsBreakpoints.includes(bp)) {
        console.warn("[Warning]! seems like there are multiple configs for breakpoint: ".concat(bp, ", this can cause unexpected behavior. Please make sure that you only have one variant config for each breakpoint."));
      }

      if (siblingsBreakpoints.includes(bp)) {
        result.push(bp);
      }
    } else {
      if (!found) {
        result.push(bp);
      } else if (isLowerBreakpointFromSibling(selfBreakpoints, siblingsBreakpoints, bp)) {
        result.push(bp);
      }
    }
  });

  return result;
};

exports.getHiddenRange = getHiddenRange;

var createHiddenStyles = function createHiddenStyles(self) {
  var siblings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var breakpoints = arguments.length > 2 ? arguments[2] : undefined;
  if (!self || !breakpoints) return {};
  var hiddenRange = getHiddenRange(self, siblings);
  return (0, _createDisplayNone["default"])(hiddenRange, breakpoints);
};

var _default = createHiddenStyles;
exports["default"] = _default;